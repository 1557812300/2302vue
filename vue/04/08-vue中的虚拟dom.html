<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  
  <!-- <div id="dom">1</div> -->

  <div id="abc">
    <p>2</p>
    <ul class="list-group"></ul>
  </div>

  <script>
    // vue中内部频繁的操作了虚拟dom （什么叫做虚拟dom? js的真实dom的映射，其实就是一个js对象）
    // jquery就是用来频繁操作真实dom元素的，如果频繁的操作真实dom元素的话，性能消耗是比较差的。


    // 1.内存中创建一颗虚拟dom树
    // const vDom = {
    //   tag:'div',
    //   attr:{id:'abc'},
    //   children:[
    //     {tag:'p',attr:null,content:2},
    //     {tag:'ul',attr:{className:'list-group'}},
    //   ]
    // }

    // 2.将内存中的虚拟dom对象做一个初始化的渲染操作，渲染成浏览器可以识别的真实dom树


    // 3. 当我们修改了vue实例中的数据的时候
    // this.arr.push('<li>1111</li><li>2222</li>')

    // 4. 将之前的虚拟dom树结合修改的数据，生成一颗全新的虚拟dom树
    // const newDom = {
    //   tag:'div',
    //   attr:{id:'abc'},
    //   children:[
    //     {tag:'p',attr:null,content:2},
    //     {tag:'ul',attr:{className:'list-group'},content:[
    //       {tag:'li',attr:null,content:'1111'},
    //       {tag:'li',attr:null,content:'2222'}
    //     ]},
    //   ]
    // }

    // 5 将生成好新的虚拟dom树与上一次的虚拟dom树进行diff算法对比，算出patch差异部分

    // 6 将对比出来的patch差异的部分去更新真实dom树，界面更新了


    // 这个代码执行时间0.3ms左右
    // console.time('temp')
    // let myDom = document.querySelector('#dom')
    // let num = 1
    // for(let i=0;i<10000;i++){
    //   num++
    // }
    // myDom.innerHTML = num
    // console.timeEnd('temp')



    // 这个代码执行时间30ms左右
    // console.time('temp')
    // let myDom = document.querySelector('#dom')
    // for(let i=0;i<10000;i++){
    //   let value = myDom.innerHTML
    //   myDom.innerHTML = ++value
    // }
    // console.timeEnd('temp')
  </script>
</body>
</html>